"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[5706],{65706:function(e,s,n){var a=n(85893);s.Z={title:()=>"Formulas",body:()=>(0,a.jsxs)("div",{children:[(0,a.jsxs)("p",{children:["Formulas allow you to use"," ",(0,a.jsx)("a",{target:"_blank",href:"https://www.ruby-lang.org",children:"Ruby"})," ","code to generate data based on custom logic. For example:"]}),(0,a.jsx)("p",{children:(0,a.jsx)("code",{children:"times_reached_base / at_bats + slugging"})}),(0,a.jsx)("h3",{children:"Operators"}),(0,a.jsx)("p",{children:(0,a.jsx)("code",{children:"+ - * / %"})}),(0,a.jsx)("h3",{children:"Logic"}),(0,a.jsx)("p",{children:(0,a.jsx)("code",{children:"< > <= >= == != and or"})}),(0,a.jsx)("h3",{children:"Conditional Statements"}),(0,a.jsx)("p",{children:(0,a.jsx)("code",{children:"if my_num % 2 == 0 then 'even' else 'odd' end"})}),(0,a.jsx)("p",{children:(0,a.jsx)("code",{children:'if score > 10 then "high" elsif score > 5 then "medium" else "low" end'})}),(0,a.jsx)("h3",{children:"Functions"}),(0,a.jsxs)("p",{children:[(0,a.jsx)("code",{children:"base64(str)"})," => encodes a string as base64"]}),(0,a.jsxs)("p",{children:[(0,a.jsx)("code",{children:"bcrypt('some password')"})," => Returns a bcrypt hash of the provided string."]}),(0,a.jsxs)("p",{children:[(0,a.jsx)("code",{children:'code("CURRENT_TIMESTAMP")'})," => returns a value that is will not be wrapped in quotes in the downloaded file. Use this to inject code into your data."]}),(0,a.jsxs)("p",{children:[(0,a.jsx)("code",{children:'concat(first_name, " ", last_name)'})," => concatenates all arguments into a single string."]}),(0,a.jsxs)("p",{children:[(0,a.jsx)("code",{children:"date('7/4/2015')"}),' => July 4, 2015. You can optionally pass a format string as a second argument. The default format is "%m/%d/%Y". See'," ",(0,a.jsx)("a",{href:"https://apidock.com/ruby/Date/strptime/class",target:"_blank",children:"Ruby Date.strptime"})," ","for more info on formats."]}),(0,a.jsxs)("p",{children:[(0,a.jsx)("code",{children:"date_diff('days', my_date, date('2015-01-01'))"})," => The numbers of days between my_date and Jan 1, 2015. 'days', 'hours', 'minutes', and 'seconds' are also supported."]}),(0,a.jsxs)("p",{children:[(0,a.jsx)("code",{children:"day(my_date_field)"})," => The day of my_date_field as an integer. Optionally specify true as a second argument to return the day as string in 2 digit format."]}),(0,a.jsxs)("p",{children:[(0,a.jsx)("code",{children:"digest(str, 'MD5|HMAC|RMD160|SHA1|SHA256|SHA384|SHA512', 'hex|base64')"})," ","=> digest of str with specific algorithm and encoding"]}),(0,a.jsxs)("p",{children:[(0,a.jsx)("code",{children:"epoch(datetime)"})," => Converts a datetime field to an epoch."]}),(0,a.jsxs)("p",{children:[(0,a.jsx)("code",{children:'field("My Field Name")'})," => gets the value of a field. Use this to access fields that start with an uppercase letter or contain non-alphanumeric characters."]}),(0,a.jsxs)("p",{children:[(0,a.jsx)("code",{children:'from_dataset("dataset", "column", join_criteria)'})," => Fetches a value from a dataset.",(0,a.jsx)("br",{}),"For example, ",(0,a.jsx)("code",{children:'from_dataset("People", "name", id: person_id)'})," ",'returns the value of the "name" column from the "People" dataset where the id column matches the person_id column in the current schema.']}),(0,a.jsxs)("p",{children:[(0,a.jsx)("code",{children:"generate(data_type, **options)"})," => generates a value using one of Mockaroo's built-in datatypes. See"," ",(0,a.jsx)("a",{target:"_blank",href:"http://localhost:3000/docs#Types",children:"Types"})," ","for a list of available data types and their parameters. For example,"," ",(0,a.jsx)("code",{children:'generate("First Name")'})," generates a random first name."," ",(0,a.jsx)("code",{children:"generate('Number', min: 0, max: 100, decimals: 0)"})," generates a random integer between 0 and 100."]}),(0,a.jsxs)("p",{children:[(0,a.jsx)("code",{children:"hex(str)"})," => encodes a string as hex"]}),(0,a.jsxs)("p",{children:[(0,a.jsx)("code",{children:'lower("XYZ")'})," => xyz"]}),(0,a.jsxs)("p",{children:[(0,a.jsx)("code",{children:"mongo_object_id(my_id)"})," => Output the value of my_id in MongoDB ObjectId JSON format"]}),(0,a.jsxs)("p",{children:[(0,a.jsx)("code",{children:"month(my_date_field)"})," => The month of my_date_field as an integer. Optionally specify true as a second argument to return the month as a string in 2 digit format."]}),(0,a.jsxs)("p",{children:[(0,a.jsx)("code",{children:"my_date + years(2)"})," => the date 2 years after my_date."," ",(0,a.jsx)("code",{children:"months"}),", ",(0,a.jsx)("code",{children:"days"}),", ",(0,a.jsx)("code",{children:"hours"}),","," ",(0,a.jsx)("code",{children:"minutes"}),", and ",(0,a.jsx)("code",{children:"seconds"})," are also available."]}),(0,a.jsxs)("p",{children:[(0,a.jsx)("code",{children:"naughty(my_field, 10)"}),' => returns a naughty string 10% of the time and the value of my_field 90% of the time. Use with hidden fields (name starting with "__") to turn nice fields into naughty fields!']}),(0,a.jsxs)("p",{children:[(0,a.jsx)("code",{children:"now()"})," => The current date and time."]}),(0,a.jsxs)("p",{children:[(0,a.jsx)("code",{children:"normal_dist(mean, std_dev, decimals)"})," => Generates a random number using a normal disribution. Mean and std_dev are required. Decimals is optional and defaults to 2."]}),(0,a.jsxs)("p",{children:[(0,a.jsx)("code",{children:'pad(field, length, fill_string, "left|right|center")'})," => pads a string to a fixed length with filler."]}),(0,a.jsxs)("p",{children:[(0,a.jsx)("code",{children:"format(number_value, decimals)"})," => formats a number as a string with a fixed number of decimal places. For example:"," ",(0,a.jsx)("code",{children:'format(1.2, 3) => "1.200"'})]}),(0,a.jsxs)("p",{children:[(0,a.jsx)("code",{children:"random(min, max)"})," => generates a random number between min and max."]}),(0,a.jsxs)("p",{children:[(0,a.jsx)("code",{children:"round(x / y, 2)"})," => rounds to 2 decimal places"]}),(0,a.jsxs)("p",{children:[(0,a.jsx)("code",{children:"time(my_datetime_field"})," => Returns only the time part of a datetime field."]}),(0,a.jsxs)("p",{children:[(0,a.jsx)("code",{children:'upper("xyz")'})," => XYZ"]}),(0,a.jsxs)("p",{children:[(0,a.jsx)("code",{children:'uuid_v5("dns", "www.mockaroo.com")'})," => generates a v5 UUID",(0,a.jsx)("br",{}),'The first parameters should be "dns", "url", "oid", or "x500". The second parameter is any string']}),(0,a.jsxs)("p",{children:[(0,a.jsx)("code",{children:"year(my_date_field)"})," => The year of my_date_field as an integer"]}),(0,a.jsx)("h3",{children:"Accessing Request Parameters when Used in a Mock API"}),(0,a.jsxs)("p",{children:[(0,a.jsx)("code",{children:"request_params['name_of_parameter']"})," => returns the value of a URL or query string parameter specified in the request"]}),(0,a.jsxs)("p",{children:[(0,a.jsx)("code",{children:"request_entity['name_of_parameter']"})," => returns the value of a key in the JSON request entity body"]}),(0,a.jsx)("h3",{children:"Handling Blanks"}),(0,a.jsxs)("p",{children:[(0,a.jsx)("code",{children:"my_num + 1 if my_num"})," => returns my_num + 1, or blank if my_num is blank"]}),(0,a.jsxs)("p",{children:[(0,a.jsx)("code",{children:"a + b if a and b"})," => returns a + b, or blank if either is blank"]}),(0,a.jsxs)("p",{children:[(0,a.jsx)("code",{children:"(my_num || 0) + 1"})," => returns my_num + 1, or 1 if my_num is blank"]}),(0,a.jsxs)("p",{children:[(0,a.jsx)("code",{children:"if my_field.nil? then 'blank' else 'not blank' end"}),' => "blank" when my_field is blank, otherwise "not blank"']}),(0,a.jsx)("h3",{children:"Accessing Nested JSON Objects"}),(0,a.jsxs)("p",{children:["When a formula field is inside of a JSON array it has access to all fields in that array as well as all fields on parent objects. Both fields in the array and parent fields are accessed"," ",(0,a.jsx)("b",{children:"without a qualifier"}),'. For example, if a formula is in an array named "myArray" that has nested field named "myArray.myField", the formula can access that field as "myField" NOT "myArray.myField". When formulas need to access fields in nested objects (not in an array), however, the fully qualified field name must be used.']}),(0,a.jsx)("h3",{children:"Generating Data using Regular Expressions"}),(0,a.jsxs)("p",{children:["You can use Ruby's ",(0,a.jsx)("code",{children:"Regexp.gen"})," method to generate data based on regular expressions. For example:",(0,a.jsxs)("code",{children:["/(A|B|C)-\\d",3,"/.gen"]})]}),(0,a.jsx)("h3",{children:"Using built-in Ruby classes and methods"}),(0,a.jsx)("p",{children:"For security purposes, not all of the Ruby language is available in Mockaroo Formulas. All methods of the following modules are whitelisted whitelisted:"}),(0,a.jsxs)("ul",{children:[(0,a.jsx)("li",{children:"Array"}),(0,a.jsx)("li",{children:"BasicObject"}),(0,a.jsx)("li",{children:"BigDecimal"}),(0,a.jsx)("li",{children:"BSON::ObjectId"}),(0,a.jsx)("li",{children:"Date"}),(0,a.jsx)("li",{children:"DateAndTime::Calculations"}),(0,a.jsx)("li",{children:"DateTime"}),(0,a.jsx)("li",{children:"Enumerable"}),(0,a.jsx)("li",{children:"Fixnum"}),(0,a.jsx)("li",{children:"Float"}),(0,a.jsx)("li",{children:"Hash"}),(0,a.jsx)("li",{children:"Integer"}),(0,a.jsx)("li",{children:"Math"}),(0,a.jsx)("li",{children:"NilClass"}),(0,a.jsx)("li",{children:"Range"}),(0,a.jsx)("li",{children:"Regexp"}),(0,a.jsx)("li",{children:"String"}),(0,a.jsx)("li",{children:"Time"})]}),"Additionally you can also declare and call lambdas. Formulas use Ruby 2.7.3."]})}}}]);